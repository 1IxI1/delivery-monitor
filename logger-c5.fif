#!/usr/bin/env fift -s

// Dummy Logger Contract code
//
// It works mainly as v3r2 wallet, but:
// - without sending messages (i.e.
//   just sign verification,
//   valid_until check, seqno update).
// - it uses no c4, but ONLY ITS CODE
//   as a STORAGE for pubkey and seqno.
// 
// On each external_msg, it applies c5 from msg,
// which should have the set_code_action with code
// generated by this (logger-c5.fif) script.

"Asm.fif" include

{ ."usage: " @' $0 type ." <seqno> <public_key>" cr
  ."Creates logger code cell with provided constant seqno (in code)." cr 1 halt
} : usage

$# 2 = { } { usage } cond

$1 (number) 1 <> abort"not an integer: check your seqno" =: seqno
$2 (number) 1 <> abort"not an integer: check your pubkey" =: pubkey

<{  SETCP0

    DUP IFNOTRET // return if recv_internal

    // "seqno" get-method
    DUP 85143 INT EQUAL
    IFJMP:<{ 
      DROP
      seqno INT
    }>

    // fail unless recv_external
    INC 32 THROWIF

    //
    // recv_external code:
    //

    // init stack: cs
    // (cs means cell slice)

    // load signature
    512 INT LDSLICEX // signature cs

    // load and check seqno
    32 LDU SWAP // signature cs seqno
    seqno INT // signature cs seqno stored_seqno
    EQUAL 82 THROWIFNOT  // signature cs

    // check timeout
    48 LDU // signature valid_until cs 
    OVER // signature valid_until cs valid_until
    NOW // signature valid_until cs valid_until now
    GEQ 77 THROWIFNOT // signature valid_until cs

    // load c5 actions cell
    PLDREF // signature valid_until set_code_action

    // mix valid_until and seqno for signature check
    SWAP // signature set_code_action valid_until 
    seqno INT MUL // signature set_code_action valid_until*seqno


    // check signature
    ROT // set_code_action valid_until*seqno signature
    pubkey INT // set_code_action valid_until*seqno signature pubkey
    CHKSIGNU 35 THROWIFNOT  // set_code_action

    // now we're left with set_code_action
    // done all checks - accept msg and update code
    ACCEPT // set_code_action
    c5 POP // none on stack - return
}>c

2 boc+>B
dup Bx. cr
"logger-code.boc" B>file

